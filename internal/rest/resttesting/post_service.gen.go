// Code generated by counterfeiter. DO NOT EDIT.
package resttesting

import (
	"art_space/internal/models"
	"art_space/internal/rest"
	"context"
	"sync"
)

type FakePostService struct {
	CreatePostStub        func(context.Context, string, int) (int, error)
	createPostMutex       sync.RWMutex
	createPostArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}
	createPostReturns struct {
		result1 int
		result2 error
	}
	createPostReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	DeletePostStub        func(context.Context, int) error
	deletePostMutex       sync.RWMutex
	deletePostArgsForCall []struct {
		arg1 context.Context
		arg2 int
	}
	deletePostReturns struct {
		result1 error
	}
	deletePostReturnsOnCall map[int]struct {
		result1 error
	}
	SelectAllPostsStub        func(context.Context) ([]models.Post, error)
	selectAllPostsMutex       sync.RWMutex
	selectAllPostsArgsForCall []struct {
		arg1 context.Context
	}
	selectAllPostsReturns struct {
		result1 []models.Post
		result2 error
	}
	selectAllPostsReturnsOnCall map[int]struct {
		result1 []models.Post
		result2 error
	}
	SelectPostByIdStub        func(context.Context, int) (models.Post, error)
	selectPostByIdMutex       sync.RWMutex
	selectPostByIdArgsForCall []struct {
		arg1 context.Context
		arg2 int
	}
	selectPostByIdReturns struct {
		result1 models.Post
		result2 error
	}
	selectPostByIdReturnsOnCall map[int]struct {
		result1 models.Post
		result2 error
	}
	UpdatePostStub        func(context.Context, int, string) error
	updatePostMutex       sync.RWMutex
	updatePostArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 string
	}
	updatePostReturns struct {
		result1 error
	}
	updatePostReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePostService) CreatePost(arg1 context.Context, arg2 string, arg3 int) (int, error) {
	fake.createPostMutex.Lock()
	ret, specificReturn := fake.createPostReturnsOnCall[len(fake.createPostArgsForCall)]
	fake.createPostArgsForCall = append(fake.createPostArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.CreatePostStub
	fakeReturns := fake.createPostReturns
	fake.recordInvocation("CreatePost", []interface{}{arg1, arg2, arg3})
	fake.createPostMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePostService) CreatePostCallCount() int {
	fake.createPostMutex.RLock()
	defer fake.createPostMutex.RUnlock()
	return len(fake.createPostArgsForCall)
}

func (fake *FakePostService) CreatePostCalls(stub func(context.Context, string, int) (int, error)) {
	fake.createPostMutex.Lock()
	defer fake.createPostMutex.Unlock()
	fake.CreatePostStub = stub
}

func (fake *FakePostService) CreatePostArgsForCall(i int) (context.Context, string, int) {
	fake.createPostMutex.RLock()
	defer fake.createPostMutex.RUnlock()
	argsForCall := fake.createPostArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePostService) CreatePostReturns(result1 int, result2 error) {
	fake.createPostMutex.Lock()
	defer fake.createPostMutex.Unlock()
	fake.CreatePostStub = nil
	fake.createPostReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakePostService) CreatePostReturnsOnCall(i int, result1 int, result2 error) {
	fake.createPostMutex.Lock()
	defer fake.createPostMutex.Unlock()
	fake.CreatePostStub = nil
	if fake.createPostReturnsOnCall == nil {
		fake.createPostReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.createPostReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakePostService) DeletePost(arg1 context.Context, arg2 int) error {
	fake.deletePostMutex.Lock()
	ret, specificReturn := fake.deletePostReturnsOnCall[len(fake.deletePostArgsForCall)]
	fake.deletePostArgsForCall = append(fake.deletePostArgsForCall, struct {
		arg1 context.Context
		arg2 int
	}{arg1, arg2})
	stub := fake.DeletePostStub
	fakeReturns := fake.deletePostReturns
	fake.recordInvocation("DeletePost", []interface{}{arg1, arg2})
	fake.deletePostMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePostService) DeletePostCallCount() int {
	fake.deletePostMutex.RLock()
	defer fake.deletePostMutex.RUnlock()
	return len(fake.deletePostArgsForCall)
}

func (fake *FakePostService) DeletePostCalls(stub func(context.Context, int) error) {
	fake.deletePostMutex.Lock()
	defer fake.deletePostMutex.Unlock()
	fake.DeletePostStub = stub
}

func (fake *FakePostService) DeletePostArgsForCall(i int) (context.Context, int) {
	fake.deletePostMutex.RLock()
	defer fake.deletePostMutex.RUnlock()
	argsForCall := fake.deletePostArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePostService) DeletePostReturns(result1 error) {
	fake.deletePostMutex.Lock()
	defer fake.deletePostMutex.Unlock()
	fake.DeletePostStub = nil
	fake.deletePostReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePostService) DeletePostReturnsOnCall(i int, result1 error) {
	fake.deletePostMutex.Lock()
	defer fake.deletePostMutex.Unlock()
	fake.DeletePostStub = nil
	if fake.deletePostReturnsOnCall == nil {
		fake.deletePostReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deletePostReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePostService) SelectAllPosts(arg1 context.Context) ([]models.Post, error) {
	fake.selectAllPostsMutex.Lock()
	ret, specificReturn := fake.selectAllPostsReturnsOnCall[len(fake.selectAllPostsArgsForCall)]
	fake.selectAllPostsArgsForCall = append(fake.selectAllPostsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.SelectAllPostsStub
	fakeReturns := fake.selectAllPostsReturns
	fake.recordInvocation("SelectAllPosts", []interface{}{arg1})
	fake.selectAllPostsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePostService) SelectAllPostsCallCount() int {
	fake.selectAllPostsMutex.RLock()
	defer fake.selectAllPostsMutex.RUnlock()
	return len(fake.selectAllPostsArgsForCall)
}

func (fake *FakePostService) SelectAllPostsCalls(stub func(context.Context) ([]models.Post, error)) {
	fake.selectAllPostsMutex.Lock()
	defer fake.selectAllPostsMutex.Unlock()
	fake.SelectAllPostsStub = stub
}

func (fake *FakePostService) SelectAllPostsArgsForCall(i int) context.Context {
	fake.selectAllPostsMutex.RLock()
	defer fake.selectAllPostsMutex.RUnlock()
	argsForCall := fake.selectAllPostsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePostService) SelectAllPostsReturns(result1 []models.Post, result2 error) {
	fake.selectAllPostsMutex.Lock()
	defer fake.selectAllPostsMutex.Unlock()
	fake.SelectAllPostsStub = nil
	fake.selectAllPostsReturns = struct {
		result1 []models.Post
		result2 error
	}{result1, result2}
}

func (fake *FakePostService) SelectAllPostsReturnsOnCall(i int, result1 []models.Post, result2 error) {
	fake.selectAllPostsMutex.Lock()
	defer fake.selectAllPostsMutex.Unlock()
	fake.SelectAllPostsStub = nil
	if fake.selectAllPostsReturnsOnCall == nil {
		fake.selectAllPostsReturnsOnCall = make(map[int]struct {
			result1 []models.Post
			result2 error
		})
	}
	fake.selectAllPostsReturnsOnCall[i] = struct {
		result1 []models.Post
		result2 error
	}{result1, result2}
}

func (fake *FakePostService) SelectPostById(arg1 context.Context, arg2 int) (models.Post, error) {
	fake.selectPostByIdMutex.Lock()
	ret, specificReturn := fake.selectPostByIdReturnsOnCall[len(fake.selectPostByIdArgsForCall)]
	fake.selectPostByIdArgsForCall = append(fake.selectPostByIdArgsForCall, struct {
		arg1 context.Context
		arg2 int
	}{arg1, arg2})
	stub := fake.SelectPostByIdStub
	fakeReturns := fake.selectPostByIdReturns
	fake.recordInvocation("SelectPostById", []interface{}{arg1, arg2})
	fake.selectPostByIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePostService) SelectPostByIdCallCount() int {
	fake.selectPostByIdMutex.RLock()
	defer fake.selectPostByIdMutex.RUnlock()
	return len(fake.selectPostByIdArgsForCall)
}

func (fake *FakePostService) SelectPostByIdCalls(stub func(context.Context, int) (models.Post, error)) {
	fake.selectPostByIdMutex.Lock()
	defer fake.selectPostByIdMutex.Unlock()
	fake.SelectPostByIdStub = stub
}

func (fake *FakePostService) SelectPostByIdArgsForCall(i int) (context.Context, int) {
	fake.selectPostByIdMutex.RLock()
	defer fake.selectPostByIdMutex.RUnlock()
	argsForCall := fake.selectPostByIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePostService) SelectPostByIdReturns(result1 models.Post, result2 error) {
	fake.selectPostByIdMutex.Lock()
	defer fake.selectPostByIdMutex.Unlock()
	fake.SelectPostByIdStub = nil
	fake.selectPostByIdReturns = struct {
		result1 models.Post
		result2 error
	}{result1, result2}
}

func (fake *FakePostService) SelectPostByIdReturnsOnCall(i int, result1 models.Post, result2 error) {
	fake.selectPostByIdMutex.Lock()
	defer fake.selectPostByIdMutex.Unlock()
	fake.SelectPostByIdStub = nil
	if fake.selectPostByIdReturnsOnCall == nil {
		fake.selectPostByIdReturnsOnCall = make(map[int]struct {
			result1 models.Post
			result2 error
		})
	}
	fake.selectPostByIdReturnsOnCall[i] = struct {
		result1 models.Post
		result2 error
	}{result1, result2}
}

func (fake *FakePostService) UpdatePost(arg1 context.Context, arg2 int, arg3 string) error {
	fake.updatePostMutex.Lock()
	ret, specificReturn := fake.updatePostReturnsOnCall[len(fake.updatePostArgsForCall)]
	fake.updatePostArgsForCall = append(fake.updatePostArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UpdatePostStub
	fakeReturns := fake.updatePostReturns
	fake.recordInvocation("UpdatePost", []interface{}{arg1, arg2, arg3})
	fake.updatePostMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePostService) UpdatePostCallCount() int {
	fake.updatePostMutex.RLock()
	defer fake.updatePostMutex.RUnlock()
	return len(fake.updatePostArgsForCall)
}

func (fake *FakePostService) UpdatePostCalls(stub func(context.Context, int, string) error) {
	fake.updatePostMutex.Lock()
	defer fake.updatePostMutex.Unlock()
	fake.UpdatePostStub = stub
}

func (fake *FakePostService) UpdatePostArgsForCall(i int) (context.Context, int, string) {
	fake.updatePostMutex.RLock()
	defer fake.updatePostMutex.RUnlock()
	argsForCall := fake.updatePostArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePostService) UpdatePostReturns(result1 error) {
	fake.updatePostMutex.Lock()
	defer fake.updatePostMutex.Unlock()
	fake.UpdatePostStub = nil
	fake.updatePostReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePostService) UpdatePostReturnsOnCall(i int, result1 error) {
	fake.updatePostMutex.Lock()
	defer fake.updatePostMutex.Unlock()
	fake.UpdatePostStub = nil
	if fake.updatePostReturnsOnCall == nil {
		fake.updatePostReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updatePostReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePostService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createPostMutex.RLock()
	defer fake.createPostMutex.RUnlock()
	fake.deletePostMutex.RLock()
	defer fake.deletePostMutex.RUnlock()
	fake.selectAllPostsMutex.RLock()
	defer fake.selectAllPostsMutex.RUnlock()
	fake.selectPostByIdMutex.RLock()
	defer fake.selectPostByIdMutex.RUnlock()
	fake.updatePostMutex.RLock()
	defer fake.updatePostMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePostService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ rest.PostService = new(FakePostService)
